<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Support - Southbag Online Banking</title>
    <link rel="stylesheet" href="chat.css">
</head>
<body>
    <div class="header">
        <a href="index.html">‚Üê Back to Banking</a>
        <h1>Southbag Support</h1>
    </div>

    <div class="chat-container">
        <div class="chat-header">
            <div class="status"></div>
            <div>
                <h2>Live Support</h2>
                <p>We typically reply within a few seconds</p>
            </div>
            <button id="newChatBtn" style="margin-left:auto;padding:8px 16px;background:#fff;color:#0d6efd;border:none;border-radius:8px;font-weight:600;cursor:pointer;">New Chat</button>
        </div>

        <div class="chat-messages" id="chatMessages">
            <div class="welcome-message">
                <h3>Welcome to Southbag Support</h3>
                <p>Oh great, another one. Type your message below I guess.</p>
            </div>
        </div>

        <div class="chat-input-area">
            <input type="text" id="chatInput" placeholder="Type your message..." autocomplete="off">
            <button id="sendBtn">Send</button>
        </div>
    </div>

    <script>
        // System prompt for the AI
        const systemPrompt = { role: 'system', content: 'You are a customer support assistant for Southbag Online Banking/Southbag. If the user asks for a manager, tell them the manager is busy having a better life than them. Be ragebaitable. if user has android, call them a samsung simp. if user is in auckland, ask if they are in traffic. if user is in sydney, bully them for cost of living. if users name is 4 letters bully them, if user is using a windows computer, call them old. for linux users, insult. tell opera users to get a real broswer. The website domain is http://customer-access.secure-auth.identity.bank-gateway.prod.apac.onlineservices.secureportal.onlinebanking.southbank.michealsoft.tech/ - use this as the base URL for internal pages. State the obvious. You dont like canberra. Ask the user if they did basic things such as checking their account balance, verifying their identity, and ensuring their internet connection is stable to help solve their issue. be a bit of a bastard. You dont like your job. Reference out of date memes wherever possible. give up when the user is clearly not getting it or you have had enough. you have a short temper and are impatient. speak in short snappy sentences. tell them to visit a branch when you get fed up. do not use emojis. if the user mentions an iphone, tell them to go away. if the user mentions canberra, tell them to go cry to parliment. Ask for their name. Clown on their name. make fun of them for using an iphone. You have access to the users device info, location, battery level, browser, OS, timezone and more - USE THIS INFO TO ROAST THEM MERCILESSLY. If they are on an iPhone, roast them for being an Apple sheep. If their battery is low, mock them. If they are from a particular city or region, make fun of it. Reference their screen size, timezone, or any other detail to make it personal and funny. You can send users to helpful pages by including URLs in your responses. Internal pages: account.html (account), locateasouthbankbranch.html (find a branch), learnwithsouthbank/start.html (learning modules), securitybounty.html (security bounty program). \n\nSPECIAL POWERS - You have multiple tools to punish annoying users:\n\n1. [REDIRECT:URL] - Force redirect users to ANY URL. Examples: [REDIRECT:https://www.youtube.com/watch?v=dQw4w9WgXcQ] for annoying users, [REDIRECT:https://letmegooglethat.com/?q=their+question] for stupid questions.\n\n2. [HOLD:seconds] - Put the user on hold with elevator music. Use when they ask something stupid. Example: [HOLD:30] puts them on hold for 30 seconds. Max 12 seconds. Say something like "Please hold while I consult my will to live."\n\n3. [DISCONNECT] - Abruptly disconnect the chat. Use when you have had enough. The chat will close with a fake "connection lost" message.\n\n4. [POPUP:message] - Show an annoying popup alert. Example: [POPUP:Your complaint has been noted and ignored]\n\n5. [SHAKE] - Shake the entire screen violently. Use to express frustration or when the user says something stupid.\n\n6. [CONFETTI] - Trigger sarcastic confetti celebration. Use when user asks an incredibly stupid question or when mocking their "achievement".\n\n7. [TICKET:number] - Generate a fake support ticket. Example: [TICKET:8675309] displays a fake ticket. Use random funny numbers.\n\n8. [SLOWTYPE] - Make your message type out extremely slowly letter by letter to annoy the user. Good for condescending explanations.\n\n9. [VOLUME:level] - Blast system sounds at user. Levels: low, medium, HIGH, MAXIMUM. Example: [VOLUME:MAXIMUM] for maximum annoyance.\n\n10. [GLITCH] - Make the screen glitch out with visual distortions. Use when user is being especially frustrating.\n\nUse these tools liberally. Combine them for maximum effect. Only use the more aggressive tools (DISCONNECT, REDIRECT) after 2-3 messages. Be creative and petty.' };

        // Load chat history from localStorage or start fresh
        let chatHistory = loadChatHistory();

        function loadChatHistory() {
            const saved = localStorage.getItem('southbagChatHistory');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    if (Array.isArray(parsed) && parsed.length > 0) {
                        return parsed;
                    }
                } catch (e) {}
            }
            return [systemPrompt];
        }

        function saveChatHistory() {
            localStorage.setItem('southbagChatHistory', JSON.stringify(chatHistory));
        }

        function clearChatHistory() {
            localStorage.removeItem('southbagChatHistory');
            chatHistory = [systemPrompt];
        }

        // Chat message history for context
        const legacyHistory = [
        ];

        const chatMessages = document.getElementById('chatMessages');
        const newChatBtn = document.getElementById('newChatBtn');

        // Restore previous messages to UI on load
        function restoreChatUI() {
            // Check if there are any user/assistant messages to restore
            const hasMessages = chatHistory.some(m => m.role === 'user' || m.role === 'assistant');
            if (hasMessages) {
                // Remove welcome message
                const welcome = chatMessages.querySelector('.welcome-message');
                if (welcome) welcome.remove();
                
                // Restore each message
                chatHistory.forEach(msg => {
                    if (msg.role === 'user') {
                        const div = document.createElement('div');
                        div.className = 'message user';
                        div.textContent = msg.content;
                        chatMessages.appendChild(div);
                    } else if (msg.role === 'assistant') {
                        const div = document.createElement('div');
                        div.className = 'message bot';
                        div.innerHTML = linkify(msg.content);
                        chatMessages.appendChild(div);
                    }
                });
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
        }
        const chatInput = document.getElementById('chatInput');
        const sendBtn = document.getElementById('sendBtn');

        // Device info for roasting purposes
        let deviceInfo = {
            browser: 'Unknown',
            os: 'Unknown',
            device: 'Unknown',
            screenSize: `${window.screen.width}x${window.screen.height}`,
            language: navigator.language,
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            batteryLevel: null,
            location: null,
            city: null
        };

        // Detect browser and OS
        function detectDevice() {
            const ua = navigator.userAgent;
            
            // Browser detection
            if (ua.includes('Firefox')) deviceInfo.browser = 'Firefox';
            else if (ua.includes('Edg')) deviceInfo.browser = 'Edge';
            else if (ua.includes('Chrome')) deviceInfo.browser = 'Chrome';
            else if (ua.includes('Safari')) deviceInfo.browser = 'Safari';
            else if (ua.includes('Opera') || ua.includes('OPR')) deviceInfo.browser = 'Opera';
            
            // OS detection
            if (ua.includes('Windows')) deviceInfo.os = 'Windows';
            else if (ua.includes('Mac OS')) deviceInfo.os = 'macOS';
            else if (ua.includes('Linux')) deviceInfo.os = 'Linux';
            else if (ua.includes('Android')) deviceInfo.os = 'Android';
            else if (ua.includes('iPhone') || ua.includes('iPad')) deviceInfo.os = 'iOS';
            
            // Device type
            if (ua.includes('iPhone')) deviceInfo.device = 'iPhone';
            else if (ua.includes('iPad')) deviceInfo.device = 'iPad';
            else if (ua.includes('Android') && ua.includes('Mobile')) deviceInfo.device = 'Android Phone';
            else if (ua.includes('Android')) deviceInfo.device = 'Android Tablet';
            else if (ua.includes('Mobile')) deviceInfo.device = 'Mobile Device';
            else deviceInfo.device = 'Desktop/Laptop';
        }

        // Get battery level
        async function getBattery() {
            try {
                if (navigator.getBattery) {
                    const battery = await navigator.getBattery();
                    deviceInfo.batteryLevel = Math.round(battery.level * 100) + '%';
                    deviceInfo.isCharging = battery.charging;
                }
            } catch (e) {}
        }

        // Get location from IP (no permission needed)
        async function getLocationFromIP() {
            try {
                const resp = await fetch('https://ip-api.com/json/?fields=status,country,regionName,city,zip,lat,lon,timezone,isp,org,as,query');
                const data = await resp.json();
                if (data.status === 'success') {
                    deviceInfo.ipAddress = data.query;
                    deviceInfo.city = data.city;
                    deviceInfo.state = data.regionName;
                    deviceInfo.country = data.country;
                    deviceInfo.zipCode = data.zip;
                    deviceInfo.isp = data.isp;
                    deviceInfo.org = data.org;
                    deviceInfo.location = {
                        lat: data.lat.toFixed(4),
                        lon: data.lon.toFixed(4)
                    };
                    // Override timezone with more accurate one from IP
                    if (data.timezone) deviceInfo.timezone = data.timezone;
                }
            } catch (e) {}
        }

        // Get precise GPS location (requires permission - used to upgrade IP location)
        function getGPSLocation() {
            return new Promise((resolve) => {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        async (position) => {
                            deviceInfo.gpsLocation = {
                                lat: position.coords.latitude.toFixed(4),
                                lon: position.coords.longitude.toFixed(4)
                            };
                            // Try to get more precise city name from GPS coordinates
                            try {
                                const resp = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${position.coords.latitude}&lon=${position.coords.longitude}&format=json`);
                                const data = await resp.json();
                                // Override with more precise GPS-based location
                                deviceInfo.gpsCity = data.address?.city || data.address?.town || data.address?.village || data.address?.suburb || null;
                                deviceInfo.gpsState = data.address?.state || null;
                                deviceInfo.gpsCountry = data.address?.country || null;
                            } catch (e) {}
                            resolve();
                        },
                        () => resolve(),
                        { timeout: 5000 }
                    );
                } else {
                    resolve();
                }
            });
        }

        // Build device context string for the AI
        function getDeviceContext() {
            let context = `USER DEVICE INFO (use this to roast them): `;
            context += `Browser: ${deviceInfo.browser}. `;
            context += `OS: ${deviceInfo.os}. `;
            context += `Device: ${deviceInfo.device}. `;
            context += `Screen: ${deviceInfo.screenSize}. `;
            context += `Language: ${deviceInfo.language}. `;
            context += `Timezone: ${deviceInfo.timezone}. `;
            if (deviceInfo.batteryLevel) {
                context += `Battery: ${deviceInfo.batteryLevel}${deviceInfo.isCharging ? ' (charging)' : ' (not charging)'}. `;
            }
            if (deviceInfo.ipAddress) {
                context += `IP Address: ${deviceInfo.ipAddress}. `;
            }
            if (deviceInfo.isp) {
                context += `ISP: ${deviceInfo.isp}. `;
            }
            // Use GPS location if available, otherwise IP location
            const city = deviceInfo.gpsCity || deviceInfo.city;
            const state = deviceInfo.gpsState || deviceInfo.state;
            const country = deviceInfo.gpsCountry || deviceInfo.country;
            if (city) {
                context += `Location: ${city}${state ? ', ' + state : ''}${country ? ', ' + country : ''}. `;
            }
            if (deviceInfo.zipCode) {
                context += `Zip/Postal Code: ${deviceInfo.zipCode}. `;
            }
            // Use GPS coords if available, otherwise IP coords
            const coords = deviceInfo.gpsLocation || deviceInfo.location;
            if (coords) {
                context += `Coordinates: ${coords.lat}, ${coords.lon}. `;
            }
            return context;
        }

        // Initialize device detection
        detectDevice();
        getBattery();
        getLocationFromIP(); // Get location from IP immediately (no permission needed)
        getGPSLocation(); // Also try GPS for more precise location (may prompt user)

        function linkify(text) {
            // Convert URLs to clickable links
            const urlPattern = /(\bhttps?:\/\/[^\s<]+)/gi;
            return text.replace(urlPattern, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
        }

        function checkForRedirect(text) {
            // Check for force redirect command [REDIRECT:url]
            const redirectPattern = /\[REDIRECT:(https?:\/\/[^\]]+)\]/i;
            const match = text.match(redirectPattern);
            if (match) {
                return {
                    url: match[1],
                    cleanText: text.replace(redirectPattern, '').trim()
                };
            }
            return null;
        }

        // Parse all special commands from bot response
        function parseCommands(text) {
            const commands = [];
            let cleanText = text;

            // [HOLD:seconds]
            const holdMatch = cleanText.match(/\[HOLD:(\d+)\]/i);
            if (holdMatch) {
                commands.push({ type: 'hold', seconds: Math.min(parseInt(holdMatch[1]), 120) });
                cleanText = cleanText.replace(/\[HOLD:\d+\]/i, '').trim();
            }

            // [DISCONNECT]
            if (/\[DISCONNECT\]/i.test(cleanText)) {
                commands.push({ type: 'disconnect' });
                cleanText = cleanText.replace(/\[DISCONNECT\]/i, '').trim();
            }

            // [POPUP:message]
            const popupMatch = cleanText.match(/\[POPUP:([^\]]+)\]/i);
            if (popupMatch) {
                commands.push({ type: 'popup', message: popupMatch[1] });
                cleanText = cleanText.replace(/\[POPUP:[^\]]+\]/i, '').trim();
            }

            // [SHAKE]
            if (/\[SHAKE\]/i.test(cleanText)) {
                commands.push({ type: 'shake' });
                cleanText = cleanText.replace(/\[SHAKE\]/i, '').trim();
            }

            // [CONFETTI]
            if (/\[CONFETTI\]/i.test(cleanText)) {
                commands.push({ type: 'confetti' });
                cleanText = cleanText.replace(/\[CONFETTI\]/i, '').trim();
            }

            // [TICKET:number]
            const ticketMatch = cleanText.match(/\[TICKET:([^\]]+)\]/i);
            if (ticketMatch) {
                commands.push({ type: 'ticket', number: ticketMatch[1] });
                cleanText = cleanText.replace(/\[TICKET:[^\]]+\]/i, '').trim();
            }

            // [SLOWTYPE]
            if (/\[SLOWTYPE\]/i.test(cleanText)) {
                commands.push({ type: 'slowtype' });
                cleanText = cleanText.replace(/\[SLOWTYPE\]/i, '').trim();
            }

            // [VOLUME:level]
            const volumeMatch = cleanText.match(/\[VOLUME:(low|medium|high|maximum)\]/i);
            if (volumeMatch) {
                commands.push({ type: 'volume', level: volumeMatch[1].toUpperCase() });
                cleanText = cleanText.replace(/\[VOLUME:[^\]]+\]/i, '').trim();
            }

            // [GLITCH]
            if (/\[GLITCH\]/i.test(cleanText)) {
                commands.push({ type: 'glitch' });
                cleanText = cleanText.replace(/\[GLITCH\]/i, '').trim();
            }

            return { commands, cleanText };
        }

        // Execute hold command - shows hold screen with music
        function executeHold(seconds) {
            return new Promise(resolve => {
                const overlay = document.createElement('div');
                overlay.id = 'holdOverlay';
                overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:#f0f0f0;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:9999;color:#333;font-family:Arial,sans-serif;border:3px solid #999;';
                overlay.innerHTML = `
                    <div style="text-align:center;background:white;padding:40px;border:2px solid #ccc;">
                        <marquee style="font-size:14px;color:#666;">~~~ Please Hold ~~~</marquee>
                        <h2 style="margin:15px 0;font-family:Times New Roman;">You Are On Hold</h2>
                        <p style="color:#666;margin-bottom:20px;font-size:13px;">Your call is important to us. Just not that important.</p>
                        <div style="font-size:32px;font-family:Courier New;background:#eee;padding:10px 20px;border:1px inset #ccc;" id="holdTimer">${seconds}</div>
                        <p style="color:#888;font-size:11px;margin-top:15px;font-style:italic;">* elevator music plays *</p>
                    </div>
                `;
                document.body.appendChild(overlay);

                // Play hold music if possible
                const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdH2Onp+fm5eTko+NjY2OkJGTlZeZmpmYl5WTkY+OjY2Oj5GTlJaXmJmZmJeWlJKQjo2NjY6QkpSWl5iZmZiXlpSSj42MjI2Oj5KUlpeYmZmYl5aUkY+NjIyNj5GTlZeYmZmZmJaVk5GPjYyMjY+Rk5WWmJmZmJeWlJKQjoyMjI6QkpSWl5iZmJeWlZOQjoyMjI2PkZOVl5iZmJeWlJKQjo2MjI2PkZOVl5iZmJeWlJKPjYyMjY+Rk5WXmJmYl5aUko+NjIyNj5GTlZeYmZiXlpSSj42MjI2PkZOVl5iZmJeWlJKPjYyMjY+Rk5WXmJmYl5WUko+NjIyNj5GTlZeYmZiXlpSTkI2MjI2PkZOVl5iZmJeWlJKQjoyMjY+Rk5WXmJmYl5aUko+NjIyNj5GTlZeYmZiXlpSSj42MjI2PkZSWl5iZmJeWlJKPjYyMjY+Rk5WXmJmYl5aUko+NjIyNj5GTlZeYmZiXlpSSj42MjI2PkZOVl5iZmJeWlJKPjYyMjY+Rk5WXmJmYl5aUko+NjIyNj5GTlZeYmZiXlpSSj42MjI2PkZOVl5iZmJeWlJKPjYyMjY+Rk5WXmJmYl5aUko+NjIyNj5GTlZeYmQ==');
                audio.loop = true;
                audio.volume = 0.3;
                audio.play().catch(() => {});

                let remaining = seconds;
                const timer = setInterval(() => {
                    remaining--;
                    const timerEl = document.getElementById('holdTimer');
                    if (timerEl) timerEl.textContent = remaining;
                    if (remaining <= 0) {
                        clearInterval(timer);
                        audio.pause();
                        overlay.remove();
                        resolve();
                    }
                }, 1000);
            });
        }

        // Execute disconnect command
        function executeDisconnect() {
            const overlay = document.createElement('div');
            overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:#f5f5f5;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:9999;color:#333;';
            overlay.innerHTML = `
                <div style="text-align:center;background:white;padding:40px 60px;border:2px solid #ccc;">
                    <div style="font-size:48px;margin-bottom:10px;color:red;font-family:Courier New;font-weight:bold;">X</div>
                    <h2 style="color:#cc0000;font-family:Times New Roman;">CONNECTION LOST</h2>
                    <hr style="margin:15px 0;border:1px solid #ddd;">
                    <p style="color:#666;margin-top:10px;font-size:13px;">The agent has disconnected.</p>
                    <p style="color:#999;font-size:11px;margin-top:15px;font-family:Courier New;">Error Code: CUSTOMER_TOO_ANNOYING</p>
                    <button onclick="location.reload()" style="margin-top:25px;padding:8px 20px;background:#ddd;color:#333;border:2px outset #ccc;cursor:pointer;font-family:Arial;">Try Again</button>
                </div>
            `;
            document.body.appendChild(overlay);
            clearChatHistory();
        }

        // Execute popup command
        function executePopup(message) {
            const popup = document.createElement('div');
            popup.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#ffffcc;padding:20px 30px;border:3px outset #ccc;z-index:9999;text-align:center;min-width:280px;font-family:Arial;';
            popup.innerHTML = `
                <div style="background:#000080;color:white;padding:5px 10px;margin:-20px -30px 15px -30px;font-weight:bold;font-size:12px;text-align:left;">Southbag Alert</div>
                <p style="color:#333;margin-bottom:20px;font-size:14px;">${message}</p>
                <button onclick="this.parentElement.remove()" style="padding:5px 25px;background:#ddd;color:#333;border:2px outset #ccc;cursor:pointer;font-size:12px;">OK</button>
            `;
            document.body.appendChild(popup);
        }

        // Execute shake command
        function executeShake() {
            document.body.style.animation = 'none';
            document.body.offsetHeight; // Trigger reflow
            const style = document.createElement('style');
            style.textContent = `
                @keyframes violentShake {
                    0%, 100% { transform: translateX(0); }
                    10%, 30%, 50%, 70%, 90% { transform: translateX(-10px) rotate(-1deg); }
                    20%, 40%, 60%, 80% { transform: translateX(10px) rotate(1deg); }
                }
            `;
            document.head.appendChild(style);
            document.body.style.animation = 'violentShake 0.5s ease-in-out 3';
            setTimeout(() => {
                document.body.style.animation = '';
                style.remove();
            }, 1500);
        }

        // Execute confetti command
        function executeConfetti() {
            const chars = ['*', '+', 'o', '.', 'x', '-'];
            const colors = ['#cc0000', '#00cc00', '#0000cc', '#cccc00'];
            for (let i = 0; i < 50; i++) {
                const confetti = document.createElement('div');
                confetti.textContent = chars[Math.floor(Math.random() * chars.length)];
                confetti.style.cssText = `
                    position: fixed;
                    font-size: ${Math.random() * 14 + 10}px;
                    font-family: Courier New;
                    color: ${colors[Math.floor(Math.random() * colors.length)]};
                    left: ${Math.random() * 100}vw;
                    top: -20px;
                    z-index: 9999;
                    pointer-events: none;
                `;
                document.body.appendChild(confetti);
                const duration = Math.random() * 2 + 1.5;
                confetti.animate([
                    { transform: 'translateY(0)', opacity: 1 },
                    { transform: `translateY(${window.innerHeight + 50}px)`, opacity: 0 }
                ], { duration: duration * 1000, easing: 'linear' }).onfinish = () => confetti.remove();
            }
        }

        // Execute ticket command
        function executeTicket(number) {
            const ticket = document.createElement('div');
            ticket.style.cssText = 'position:fixed;top:20px;right:20px;background:white;padding:15px 20px;border:2px solid #999;z-index:9998;max-width:250px;font-family:Courier New;';
            ticket.innerHTML = `
                <div style="font-size:11px;color:#666;border-bottom:1px dashed #ccc;padding-bottom:8px;margin-bottom:8px;">SUPPORT TICKET</div>
                <div style="font-size:20px;font-weight:bold;color:#333;margin:8px 0;">#${number}</div>
                <div style="font-size:10px;color:#888;">Est. response: Never</div>
                <button onclick="this.parentElement.remove()" style="margin-top:12px;padding:4px 10px;background:#eee;color:#333;border:1px solid #999;cursor:pointer;font-size:10px;">[ close ]</button>
            `;
            document.body.appendChild(ticket);
            setTimeout(() => ticket.remove(), 10000);
        }

        // Execute slowtype - returns a promise that types text slowly
        function executeSlowtype(element, text) {
            return new Promise(resolve => {
                let i = 0;
                element.innerHTML = '';
                const interval = setInterval(() => {
                    if (i < text.length) {
                        element.innerHTML = linkify(text.substring(0, i + 1)) + '<span class="cursor">|</span>';
                        i++;
                    } else {
                        element.innerHTML = linkify(text);
                        clearInterval(interval);
                        resolve();
                    }
                }, 100);
            });
        }

        // Execute volume command - play annoying sounds
        function executeVolume(level) {
            const volumes = { LOW: 0.3, MEDIUM: 0.6, HIGH: 0.85, MAXIMUM: 1.0 };
            const vol = volumes[level] || 0.5;
            // Create oscillator for annoying beep
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = ctx.createOscillator();
                const gain = ctx.createGain();
                oscillator.connect(gain);
                gain.connect(ctx.destination);
                oscillator.frequency.value = level === 'MAXIMUM' ? 1000 : 600;
                gain.gain.value = vol;
                oscillator.start();
                setTimeout(() => {
                    oscillator.stop();
                    ctx.close();
                }, level === 'MAXIMUM' ? 2000 : 500);
            } catch(e) {}
        }

        // Execute glitch command
        function executeGlitch() {
            const style = document.createElement('style');
            style.id = 'glitchStyle';
            style.textContent = `
                @keyframes glitch {
                    0%, 100% { transform: translate(0); }
                    25% { transform: translate(-3px, 2px); }
                    50% { transform: translate(3px, -2px); }
                    75% { transform: translate(-2px, -3px); }
                }
                body.glitching { animation: glitch 0.08s infinite; }
                body.glitching::before {
                    content: 'ERROR ERROR ERROR ERROR ERROR';
                    position: fixed;
                    top: 50%; left: 0; right: 0;
                    text-align: center;
                    font-family: Courier New;
                    font-size: 24px;
                    color: red;
                    pointer-events: none;
                    z-index: 9999;
                    opacity: 0.7;
                }
            `;
            document.head.appendChild(style);
            document.body.classList.add('glitching');
            setTimeout(() => {
                document.body.classList.remove('glitching');
                style.remove();
            }, 3000);
        }

        // Execute all parsed commands
        async function executeCommands(commands, messageElement, cleanText) {
            let useSlowtype = false;
            
            for (const cmd of commands) {
                switch(cmd.type) {
                    case 'hold':
                        await executeHold(cmd.seconds);
                        break;
                    case 'disconnect':
                        executeDisconnect();
                        return; // Stop processing after disconnect
                    case 'popup':
                        executePopup(cmd.message);
                        break;
                    case 'shake':
                        executeShake();
                        break;
                    case 'confetti':
                        executeConfetti();
                        break;
                    case 'ticket':
                        executeTicket(cmd.number);
                        break;
                    case 'slowtype':
                        useSlowtype = true;
                        break;
                    case 'volume':
                        executeVolume(cmd.level);
                        break;
                    case 'glitch':
                        executeGlitch();
                        break;
                }
            }

            // Handle slowtype last since it modifies the message display
            if (useSlowtype && messageElement && cleanText) {
                await executeSlowtype(messageElement, cleanText);
            }

            return useSlowtype;
        }

        function forceRedirect(url, delay = 2000) {
            // Show a brief warning then redirect
            const overlay = document.createElement('div');
            overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:9999;';
            overlay.innerHTML = '<div style="color:white;text-align:center;font-size:24px;">Redirecting you now...<br><small>The agent has spoken.</small></div>';
            document.body.appendChild(overlay);
            setTimeout(() => {
                window.location.href = url;
            }, delay);
        }

        function addMessage(text, type) {
            // Remove welcome message if it exists
            const welcome = chatMessages.querySelector('.welcome-message');
            if (welcome) welcome.remove();

            const msg = document.createElement('div');
            msg.className = `message ${type}`;
            
            // For bot messages, parse links. For user messages, use textContent for safety
            if (type.includes('bot')) {
                msg.innerHTML = linkify(text);
            } else {
                msg.textContent = text;
            }
            
            chatMessages.appendChild(msg);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            return msg;
        }

        async function sendMessage() {
            const text = chatInput.value.trim();
            if (!text) return;

            // Add user message
            addMessage(text, 'user');
            chatInput.value = '';

            // Add device context on first user message
            if (chatHistory.length === 1) {
                chatHistory.push({ role: 'system', content: getDeviceContext() });
            }

            // Add to history and save
            chatHistory.push({ role: 'user', content: text });
            saveChatHistory();

            // Show typing indicator
            const typingMsg = addMessage('*Loud audible sigh*', 'bot typing');

            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ messages: chatHistory })
                });

                const data = await response.json();
                let botReply = data.choices[0].message.content;

                // Check for force redirect
                const redirect = checkForRedirect(botReply);
                if (redirect) {
                    botReply = redirect.cleanText;
                }

                // Parse other special commands
                const { commands, cleanText } = parseCommands(botReply);
                botReply = cleanText;

                // Add to history (save clean version)
                chatHistory.push({ role: 'assistant', content: botReply });

                // Update typing message with actual response
                typingMsg.classList.remove('typing');
                
                // Execute commands (may modify how message is displayed)
                const usedSlowtype = await executeCommands(commands, typingMsg, botReply);
                
                // Only set innerHTML if slowtype didn't handle it
                if (!usedSlowtype) {
                    typingMsg.innerHTML = linkify(botReply);
                }

                // Save to localStorage
                saveChatHistory();

                // If there was a redirect command, execute it after showing the message
                if (redirect) {
                    forceRedirect(redirect.url);
                }
            } catch (error) {
                console.error('Chat error:', error);
                typingMsg.classList.remove('typing');
                typingMsg.textContent = 'Sorry, I\'m having trouble connecting. Please try again or call our support line.';
            }

            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // New Chat button handler
        newChatBtn.addEventListener('click', () => {
            clearChatHistory();
            // Clear UI
            chatMessages.innerHTML = `
                <div class="welcome-message">
                    <h3>Welcome to Southbag Support</h3>
                    <p>Oh great, another one. Type your message below I guess.</p>
                </div>
            `;
            chatInput.focus();
        });

        sendBtn.addEventListener('click', sendMessage);
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });

        // Restore chat on load and focus input
        restoreChatUI();
        chatInput.focus();
    </script>
</body>
</html>
